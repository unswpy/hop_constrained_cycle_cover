#pragma once
#include "graph.h"
void set_new_total_order(NODE_TYPE node_num, vector<NODE_TYPE>* adjacency_list, vector<NODE_TYPE>* adjacency_list_reverse, NODE_TYPE* map_table);
NODE_TYPE* get_reverse_map_table(NODE_TYPE node_num, NODE_TYPE* map_table);
void construct_k_total_index(NODE_TYPE node_num, vector<map_distance_node_pair> &in_label, vector<map_distance_node_pair> &out_label, vector<NODE_TYPE>* adjacency_list, vector<NODE_TYPE>* adjacency_list_reverse, vector<NODE_TYPE>* adjacency_list_double, vector<int> in_degrees, vector<int> out_degrees, int k, vector<NODE_TYPE>& map_node_to_total_order, int& cur_low_total_order, set<NODE_TYPE> label_nodes);
void construct_k_total_index_dfs(vector<NODE_TYPE >* adjacency_list_double, vector<NODE_TYPE >* adjacency_list, NODE_TYPE src, vector<NODE_TYPE>& c_path, int k, NODE_TYPE cur_node, int cur_distance, set<NODE_TYPE>& c_path_set, vector<map_distance_node_pair> &in_label, vector<map_distance_node_pair> &out_label, NODE_TYPE mindis_in_curpath);// distance means length of path
set<NODE_TYPE> k_reach_from_node_s(NODE_TYPE s, NODE_TYPE node_num, vector<NODE_TYPE>* adjacency_list, vector<NODE_TYPE>* adjacency_list_reverse, int k);
void dfs_with_total_order(vector<NODE_TYPE >* adjacency_list_double, vector<NODE_TYPE >* adjacency_list, map<NODE_TYPE, paths> &result, NODE_TYPE cur_node, vector<NODE_TYPE> c_path, set<NODE_TYPE> stop_nodes, int distance, int cur_distance, int& min_stop_disatance, set<NODE_TYPE> c_path_set, vector<map_distance_node_pair> &in_label, vector<map_distance_node_pair> &out_label, NODE_TYPE dst,set<NODE_TYPE>& label_nodes);
void get_in_out_degrees(vector<int>& in_degrees, vector<int>& out_degrees, vector<NODE_TYPE >* adjacency_list_double, vector<NODE_TYPE >* adjacency_list, int node_num);
void construct_k_total_index_dfs_without_recursion(vector<NODE_TYPE >* adjacency_list_double, vector<NODE_TYPE >* adjacency_list, NODE_TYPE src, int k, vector<map_distance_node_pair> &in_label, vector<map_distance_node_pair> &out_label, int node_num, vector<NODE_TYPE>& map_node_to_total_order, int& cur_low_total_order);//not use adjacency double 
paths find_all_paths_with_hotpoints_dfs_with_total_order_dynamic(vector<NODE_TYPE >* adjacency_list_double, vector<NODE_TYPE >* adjacency_list, vector<NODE_TYPE >* adjacency_list_reverse, NODE_TYPE  node_num, NODE_TYPE  query_node1, NODE_TYPE  query_node2, NODE_TYPE  k, set<NODE_TYPE> hot_points, path_index &index, vector<map_distance_node_pair> &in_label, vector<map_distance_node_pair> &out_label, vector<map_distance_node_pair> &I_out, vector<map_distance_node_pair> &I_in, vector<NODE_TYPE>& map_node_to_total_order, int& cur_low_total_order, set<NODE_TYPE>& label_nodes);
void dynamic_k_reach_total_order_test(int k, int option, int threshold1, double threshold2, long query_num, char* dataset, bool output_result, char* algorithm, bool random_query);
set<NODE_TYPE> find_hot_points_total_order(vector<NODE_TYPE >* adjacency_list_double, vector<NODE_TYPE >* adjacency_list, vector<NODE_TYPE >* adjacency_list_reverse, NODE_TYPE  node_num, NODE_TYPE  k, vector<NODE_TYPE>& map_node_to_total_order, int& cur_low_total_order, double threshold);
void consruct_I_in_out(NODE_TYPE  node_num, vector<map_distance_node_pair> &in_label, vector<map_distance_node_pair> &out_label, vector<map_distance_node_pair> &I_out, vector<map_distance_node_pair> &I_in);
paths single_direction_baseline_stop_at_hotpoints_dfs(vector<NODE_TYPE >* adjacency_list, NODE_TYPE  node_num, NODE_TYPE  query_node1, NODE_TYPE  query_node2, NODE_TYPE  k, set<NODE_TYPE> hot_points);
unordered_map<NODE_TYPE, DISTANCE_TYPE> BFS_from_t(NODE_TYPE t, vector<NODE_TYPE>* adjacency_list_reverse, int k, set<NODE_TYPE> block_nodes);
void list_paths_theoryG(vector<NODE_TYPE>* adjacency_list, vector<NODE_TYPE>* adjacency_list_reverse, NODE_TYPE cur_node, NODE_TYPE query_node1, NODE_TYPE query_node2, int k, paths &result, set<NODE_TYPE> c_path_set, int cur_distance, vector<NODE_TYPE> c_path);
void list_paths_theoryG_plus(vector<NODE_TYPE>* adjacency_list, vector<NODE_TYPE>* adjacency_list_reverse, NODE_TYPE cur_node, NODE_TYPE query_node1, NODE_TYPE query_node2, int k, paths &result, set<NODE_TYPE> c_path_set, int cur_distance, vector<NODE_TYPE> c_path);